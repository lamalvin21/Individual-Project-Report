\chapter{Context}
This chapter will contextualise the dataset and project, providing an understanding of all relevant information included in the organ dataset. Also, the chapter provides a brief introduction to the tool being used: SPARQL Anything as well as a justification for using this tool over others. 

\section{Organs}
\hspace{0.5cm} The dataset provided revolves around the musical instrument: Organs. Mozart once described organs as:

\vspace{-0.15cm}
\begin{displayquote}
    \textit{``The king of instruments."}
\end{displayquote}
\vspace{-0.15cm}

An organ can come in various different sizes ranging from a small upright piano to a large structure consisting of many sub-systems. This chapter will provide a description of the instrument's components.

\subsection{A Brief History}
\hspace{0.5cm} 
The inventor of the organ is accredited by many sources to an engineer in Alexandria during the third century BC called Ctesibius. In the first century AD, organs used water and hydraulic engineering to generate sound \cite{organhistory}.

During the 14th century, organs evolved from the use of just pedals and saw the development of a keyboard so a larger range of sounds could be made. This was accommodated by the creation of new pipes so having access to more of these unique sounds was beneficial. These organs laid the building blocks for the organs we recognise today \cite{organmedivalhistory}.

Due to technological advancements, creation of organs became a lot easier allowing them to become more complex. Recent organ builders have had access to a plethora of materials and tools required to create these large structures with complex systems. Being able to study and explore different types of organs with ease, also aided the evolution of such structures \cite{organhistory1}.

\noindent \subsection{How Organs Work:}
\hspace{0.5cm} Operation of the organ involves generating and directing airflow to the requested pipe causing them to vibrate and produce sound. The organist uses the keyboards and pedals to control the flow of air to pipes and draws stops to combine different sets of pipes to produce unique, blended sounds \cite{organvideo}.

\noindent Generally, the organ system works as follows:
\vspace{-0.15cm}
\begin{enumerate}
    \itemsep0em 
\item Note is played on the keyboard.
\vspace{-0.1cm}
\item Pressurised air is passed through the organ system.
\vspace{-0.1cm}
\item When a particular stop is pulled, an internal slider is moved to allow air to pass through pipes.
\vspace{-0.1cm}
\item Sound for that particular key and stop is produced.
\end{enumerate}
\vspace{-0.1cm}

\noindent Relevant components of the organ and organ dataset are described below. 

\noindent \textbf{Pipe Types:}
\\ \hspace*{0.5cm} The particular type of pipe in an organ can significantly affect the produced sound and tone. Below, are the two main types of pipes used in an organ. 
\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
\item \underline{Reed Pipes}: Passes air through a reed (similar to a clarinet).
\item \underline{Flue Pipes}: Forces air through a pipe (similar to a recorder).
\end{itemize}
\vspace{-0.2cm}
\cite{organvideo}

\noindent \textbf{Rank:}
\\ \hspace*{0.5cm} A rank is a row of pipes (controlled by a single stop) that produces the same musical sound but does so at different pitches. 

For example, a rank of spire flue pipes all produce the same wind instrument sound, but each key pressed will produce a different flue pitch \cite{organvideo}. 

\noindent \textbf{Stops:}
\\ \hspace*{0.5cm}Drawing/selecting a stop gives the organist access to that stop's set of pipes available (for a particular key on the keyboard). Types of stops include:
\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
\item Draw Stops
\vspace{-0.1cm}
\item Tabs
\end{itemize}
\vspace{-0.15cm}

Multiple stops can be drawn at once in the same division and multiple pipes will produce sound (pressurised air will be passed through them) from the press of one key \cite{organvideo}.

\noindent \textbf{Divisions:}
\\ \hspace*{0.5cm} An organ division is a set of pipes found within an organ controlled by the keyboard or pedals. Stops of an organ are arranged into divisions, which are usually given unique names. For example, some divisions include:

\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
\item Swell (smaller pipes).
\vspace{-0.1cm}
\item Great (larger pipes).
\vspace{-0.1cm}
\item Pedal.
\vspace{-0.1cm}
\item Choir.
\vspace{-0.1cm}
\item Positiv.
\end{itemize}
\vspace{-0.15cm}

All of these divisions usually accompany whatever is deemed appropriate for the given context. For example, when accompanying a choir, using the choir division would be suitable so as to not drown out the voices of the choir \cite{organvideo}. 

\noindent \textbf{Coupler:}
\\ \hspace*{0.5cm} A coupler enables the keyboard of one division to play the stops of another division. (i.e. the combining of divisions). For example, the ``Great" division is usually played on the manual (keyboard) of the organ, but pulling the ``Great to Pedal" coupler can allow for this division to be played on the pedals \cite{organvideo}.

\noindent \textbf{Wind System:}
\\ Wind systems are responsible for:

\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
\item Producing
\vspace{-0.1cm}
\item Storing
\vspace{-0.1cm}
\item Delivering
\end{itemize}
\vspace{-0.15cm}

\noindent air within the organ system.

The organ wind system is a subsystem of the organ, which is responsible for delivering air to the organ's different pipes. Wind is generated within the system and then directed through a series of channels to the organ's pipes. Upon delivery of air to each individual pipe, a sound is made based on the key or pedal pressed \cite{organvideo}.

\section{Polifonia Project}
\hspace{0.5cm} The Polifonia project is a European project funded by the EU Horizon 2020 Programme that will manifest the connections between musical heritage from the 16th century to present day \cite{polifonia}. The project involves many different types of experts from Musicologists to Computer Scientists attempting to find links between different parts of musical cultural heritage. 

The main aim of this project is to combine computational tools and methods to access and manipulate musical cultural heritage on the WWW. Another aim is to use these computational methods in a different context (independent of the Computer Science field) and test whether such techniques can be adequately applied elsewhere. Hence, the involvement of experts from all over Europe to facilitate the project's progression \cite{polifoniaproject}.

The objective of this report is to create a knowledge graph in the context of organs as part of the Polifonia project. The provided dataset, which was derived from an organ encyclopedia, was organised and computationally formatted by a musicologist as part of this project. The provided organ ontology \cite{organontology} was created by an ontology engineer but is vast and requires adjustment to match the scope of this report. Due to the project being European-based, data stored in the dataset is in Dutch and the knowledge graph created will also produce Dutch text or terms. More detail on the provided dataset and ontology are provided in the following subsections.  

\subsection{Organ Dataset}
\hspace{0.5cm} The organ dataset provided describes various details regarding a given organ. The dataset, itself, is split into many different files and groups specific details about an organ into one JSON file. Each JSON file contains information about many different organs, which can be uniquely identified by their id. The structure of the JSON files follows the same format: an organ and the corresponding details concerning that organ. An example of two files ``base.json" and ``history\_base.json" can be seen below. 

\lstset
{
    breaklines=true,
    breakatwhitespace=false,
    basicstyle=\linespread{1.25}\ttfamily,
}
\begin{lstlisting}[caption=base.json extract]
    {
      "Part01_001MIDDE": {                  # Unique Organ Code
        "building": "Koorkerk",             # Basic organ details
        "monumentnumber": "28671",
        "name": "Middelburg, Koorkerk",
        "organnumber": "971",
        "place": "Middelburg",
        "whichorgan": "",
        "year": "1479"
      },
      "Part01_002UTREJ": {
        "building": "Jacobikerk",
        "monumentnumber": "36148",
        "name": "Utrecht, Jacobikerk",
        "organnumber": "1514",
        "place": "Utrecht",
        "whichorgan": "",
        "year": "1509"
      },
      ... # Other organs
    }
\end{lstlisting}

\lstset
{
    breaklines=true,
    breakatwhitespace=false,
    basicstyle=\linespread{1.25}\ttfamily,
}
\begin{lstlisting}[caption=history\_base.json extract]
    {
      "Part01_001MIDDE": {                 # Unique Organ Code
        "builder": "Peter Gerritsz",       # Basic organ history
        "originallocation": "Utrecht, Nicolaikerk",
        "year": "1479"
      },
      "Part01_002UTREJ": {
        "builder": "Gerrit Petersz",
        "originallocation": "",
        "year": "1509"
      },
      ... # Other organs
    }
\end{lstlisting}

The data is split into multiple different files containing the unique organ identifier with its relevant grouped data. The dataset contains data in Dutch since the Polifonia Project is a European project.

\subsection{Organ Ontology}
\hspace{0.5cm} The provided organ ontology \cite{organontology} contains all the relevant information relating to an organ, ranging from its location to the parts within it. 

\noindent The classes included in the ontology for the organ system are:

\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
    \item Organ Console
    \vspace{-0.1cm}
    \item Organ Wind System
    \vspace{-0.1cm}
    \item Organ Case
    \vspace{-0.1cm}
    \item Organ Action
    \vspace{-0.1cm}
    \item Organ Division
\end{itemize}
\vspace{-0.15cm}

\noindent  But the ontology also includes classes about a particular organ's owner and offers background on a given organ. For example:

\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
\item Description
\vspace{-0.1cm}
\item Agent and the role of this agent (owner, organist, builder etc.)
\end{itemize}
\vspace{-0.15cm}

The ontology is extremely vast and may contain nodes or relationships that do not appear within the dataset. Therefore, refinement and adjustment of the ontology, to fit the needs of the provided dataset, is required. Carefully selecting parts of the ontology to act as the framework for the resulting knowledge graph is vital to ensure all relevant data in the dataset is accurately represented. 

\section{SPARQL Anything}
\hspace{0.5cm} The tool selected for knowledge graph generation is SPARQL Anything \cite{sparqlanythinggithub}. The main purpose of this tool was to assist Semantic Web practitioners in dealing with heterogeneous data sources \cite{asprino2023knowledge}. The fa\c{c}ade design pattern was used to wrap non-RDF resources such as JSON and make them queryable as if they were RDF \cite{sparqlanything}. In general, this design pattern improves the usability of a complex system by providing a simpler and more intuitive interface to it. In this case, SPARQL Anything masks its complex components by allowing the user to continue to use SPARQL 1.1 query language, so familiar functions such as BIND() or CONCAT() can be applied, simplifying the knowledge graph generation procedure. Therefore, the time required to learn how to use such a tool would be short as there is an abundance of resources available related to learning SPARQL 1.1 query language, in contrast to other tools which may require learning new syntax or a new language. 

SPARQL Anything includes several useful attributes. For example, the SERVICE operator allows access to SPARQL Anything's features within a standard SPARQL query by overriding SPARQL 1.1's SERVICE operator with a virtual endpoint \cite{asprino2023knowledge}. Additionally, the CONSTRUCT operator can be used to generate knowledge graphs based on a specified ontology. 

\section{Other Tools}
\hspace{0.5cm} This section will detail alternate methods of knowledge graphs generation describing the approach as well as providing a comparison with SPARQL Anything. These existing methods were considered as an approach to implementation but eventually decided against them. 

\subsection{SPARQL-Generate and RML}
\hspace{0.5cm} Other solutions similar to SPARQL Anything's approach and implementation include SPARQL-Generate and RML. 

\subsubsection{SPARQL-Generate}
\hspace{0.5cm} SPARQL-Generate is an extension of SPARQL 1.1 and generates RDF from an RDF formatted dataset or documents in arbitrary formats. Expansion from SPARQL 1.1's syntax allows for the use of a new clause called GENERATE, which allows for RDF generation. \cite{lefranccois2017sparql}

Compared with SPARQL Anything, SPARQL-Generate does have some minor disadvantages. Primarily, SPARQL-Generate does not support metadata or embedded data formats, so SPARQL Anything is the only tool covering such structures \cite{sparqlanything}, allowing for more flexibility during implementation. Although SPARQL-Generate is an extension of SPARQL 1.1 and has lower learning demands, it still requires research of a newly created extension. Key terms such as GENERATE will have to be explored whereas SPARQL Anything, because it uses Facade-X, is solely reliant on SPARQL 1.1 query language knowledge \cite{sparqlanything}. As a result, adaptability is also improved since functions in SPARQL 1.1's language should suffice. SPARQL-Generate, in comparison, also has an ITERATOR clause allowing for iterator functions that enable the duplication of a BIND, for example \cite{lefranccois2017sparql}. However, an understanding of SPARQL-Generate's extensions can not be expected \cite{sparqlanything}. For those looking to continue work on this project, having a typical Semantic Web engineering workflow will be beneficial as we can assume preexisting experience with SPARQL 1.1. 

In terms of complexity, SPARQL Anything performs better in experiments using the number of distinct items or variables as a measurement for complexity \cite{sparqlanything}. Tests run based on input size have shown similar performance times with both SPARQL-Generate and SPARQL Anything so there are no differences in that regard. Nonetheless, this was important when considering possible expansion of the knowledge graph and when assessing the speed of query execution. 

\subsubsection{RML}
\hspace{0.5cm} RML is a mapping language based on R2RML: W3C's standard for mapping relational databases into RDF \cite{dimou2014rml}. Similar to SPARQL Anything and SPARQL-Generate, RML allows for the mapping of heterogeneous data sources. 

In contrast to SPARQL Anything, RML does not support metadata, embedded data or plain text formats \cite{sparqlanything}, thus constraining its versatility. In RML, the steps required to transform data formats into RDF are tedious as it requires data to be transformed before being uploaded into a SPARQL triple store, whereas SPARQL Anything allows direct resource querying \cite{sparqlanything}.

Due to RML's extension of the R2RML vocabulary, a new mapping language will have to be learnt in order to use this tool \cite{sparqlanything}, making the studying overhead far greater than SPARQL Anything's. Those looking to extend the project may require more time to understand RML than SPARQL Anything due to (assumed) prior knowledge of SPARQL 1.1 query language. Additional methods, on top of R2RML, such as \textit{rml:iterator} and \textit{rml:referenceFormulation} \cite{dimou2014rml}, facilitate the transformation process to RDF. Nevertheless, SPARQL Anything's exclusive reliance on SPARQL 1.1 results in improved adaptability \cite{sparqlanything}.  

\subsection{Large Language Models}
\hspace{0.5cm} A large language model (LLM) is a type of artificial intelligence (AI) that can carry out a variety of natural language processing tasks \cite{rouse_2023}. These are trained on millions upon millions of input data, ensuring high levels of accuracy and precision, so creation of tools such as artificial chatbots could be as accurate and broad as possible. Knowledge graph generation using LLMs has not yet been fully explored in research. A specific example of an LLM chatbot that may offer a viable solution to knowledge graph generation, due to its extensive knowledge and expertise, is a recent tool ChatGPT. 

ChatGPT is a machine-learning-based tool developed by OpenAI and is an interactive chatbot. Answers provided by ChatGPT are conversational so are easy to understand and is suggested to be the best chatbot to date \cite{chatgpt}. OpenAi released a prototype chatbot on 30th November 2022 and is currently free to use. Uses of ChatGPT include:

\vspace{-0.15cm}
\begin{itemize}
    \itemsep0em 
\item Solving programming questions.
\vspace{-0.1cm}
\item Fixing bugs in code.
\end{itemize}
\vspace{-0.15cm}

\noindent When asked to create a knowledge graph regarding organs, ChatGPT produced:

\lstset
{
    breaklines=true,
    breakatwhitespace=true,
    basicstyle=\linespread{1.5}\ttfamily,
}
\begin{lstlisting}
    Nodes: Keyboard, Pedals, Pipes, Blower, Stops
    Edges:
        -  The keyboard is connected to the pipes, indicating that pressing keys on the keyboard causes the corresponding pipes to produce sound.
        -  The pedals are connected to the pipes, indicating that pressing the pedals can also cause certain pipes to produce sound.
        -  The blower is connected to the pipes, indicating that the blower supplies air to the pipes, allowing them to produce sound.
        -  The stops are connected to the pipes, indicating that the stops control which pipes are active and can produce sound.
\end{lstlisting}

This response represents a small knowledge graph mainly comprised of organ parts and how it produces sound. The output of the knowledge graph is in plain text, which requires manual reading and interpretation, rendering it unusable for machines.

This approach is a very straightforward technique for generating an organ-related knowledge graph and makes use of the strengths of ChatGPT. The knowledge graph, although in prose, is very useful and easy to interpret due to ChatGPT's ability to communicate conversationally. The information provided is based on the chatbot's general understanding of the organ and is consistent with the instrument's details. The nodes and edges stated in the knowledge graph are also consistent with the elements of an organ. 

However, this approach generates a small knowledge graph and has to be interpreted correctly in prose. The validity of the produced knowledge graph is limited as it only includes general topics related to organs, without any real-world data. As a result, the generated graph is more akin to an ontology than a knowledge graph. The limitations of ChatGPT include that it is restricted to its input domain \cite{chatgptwebsite}, so real-world data can not be found and passed into this ontology to create an accurate knowledge graph. 

In conclusion, the knowledge graph produced by ChatGPT is closer to an organ ontology. The limitations surrounding ChatGPT do confine it to providing a generic solution. SPARQL Anything offers a more reliable approach to knowledge graph generation because real-world data can be displayed on the knowledge graph. However, if ChatGPT can evolve to find a way to gather real-world data online using the Semantic Web, for instance, the knowledge graph created would be a viable solution.
