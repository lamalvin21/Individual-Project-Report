\chapter{Design}
This design chapter provides a high-level overview of what my software will do. With the aid of visual tools such as diagrams, I will create a basic plan for implementation. 

\section{Query Flow Diagram}
\hspace{0.5cm} A flow diagram is a graphical representation of the sequence of steps or actions that need to be taken to complete a process. \cite{flowchart}

In this section, I will illustrate the logic required to build the SPARQL Anything Query in the form of a flow diagram. This will help provide me the framework in order to build the query and produce a knowledge graph.

\bigskip
\begin{center}
    \begin{tikzpicture} [
        circle/.style={draw=green, ellipse, ultra thick, fill=green!30},
        align=center,
        node distance=2.5cm ]
    \node[circle] (q0) {Add ontology};
    \node[circle, below of=q0] (q1)  {Query dataset};
    \node[circle, below of=q1] (q2)  {Clean \& Refine data};
    \node[circle, below of=q2] (q3)  {Get external links};
    \node[circle, below of=q3] (q4)  {String manipulation with external links};
    \node[circle, below of=q4] (q5)  {Add to Knowledge graph};
    \node[circle, below of=q5] (q6)  {Add any other external links};
    \node[circle, below of=q6] (q7)  {Output Knowledge Graph};

    \draw[->] (q0.south) -- (q1.north);
    \draw[->] (q1.south) -- (q2.north);
    \draw[->] (q2.south) -- (q3.north) node [midway, fill=white] {Using cleaned data};
    \draw[->] (q3.south) -- (q4.north);
    \draw[->] (q4.south) -- (q5.north);
    \draw[->] (q5.south) -- (q6.north);
    \draw[->] (q6.south) -- (q7.north);
    \draw[->] (q2.east) to [out=0,in=0] (q5.east);

    \end{tikzpicture}
\end{center}

This diagram illustrates the logic required for the SPARQL Anything query and lays the foundation for the query to be built. The nodes in the diagram represent actions that need to be done and the edges are sometimes explicitly stated transitions so that the process is more clear when I start the implementation phase. Below, I will provide an explanation of each node: 

\begin{enumerate}
  \item 'Add ontology' node refers to the addition of the ontology to the query.
  \item 'Query dataset' node uses SPARQL Anything to search for and find the relevant data within the dataset.
  \item 'Clean \& Refine data' node involves two pathways to account for the data with no external links, which skips the steps involving them.
  \item 'Get external links' node uses the clean and refined data above to find other links, but only if requested.
  \item 'String manipulation with external links' node configures the links in a readable or useful format to be put into the knowledge graph.
  \item 'Add to knowledge graph' node adds both the clean and refined data from the third node as well as the external links to the knowledge graph.
  \item 'Add any other external links' node adds any other links that do not require data from the dataset.
  \item 'Output knowledge graph' node produces the result.
\end{enumerate}

\section{Query Skeleton Structure}
\hspace{0.5cm} In this section, I will use the flow diagram illustrated in the previous section to write the skeleton of the query I am going to create.

\lstset
{
    breaklines=true,
    breakatwhitespace=true,
    basicstyle=\ttfamily,
}
\begin{lstlisting}
PREFIX ... # Add relevant links

CONSTRUCT {
    ... # Add organ ontology
} 
WHERE 
    { 
        SERVICE <file:///...>  # Query dataset
            { ... # Clean and refine data AND # Data out
                WHERE SERVICE <https://query.wikidata.org/...> ... # Query external links
                ... # Clean and Refine external data AND         # External data out
            }
            ... # Merge dataset data with external data
            # Output graph
    }

\end{lstlisting}

This basic query skeleton satisfies all the nodes in the flow graph above and can be used in the creation of the query that generates the knowledge graph. I commented on the lines of the skeleton query where the nodes were relevant by adding a comment starting with a '\#'. 
